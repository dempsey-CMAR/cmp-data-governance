---
title: "Thresholds"
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 600, fig.width = 8)

library(dplyr)
library(here)
library(knitr)
library(htmltools)
library(lubridate)
library(plotly)
library(stringr)
library(summaryplots)

source(here("pages/import_data_and_params.R"))

dat_temp <- readRDS(here("pages/data/temp_rolling_sd_prelim_qc.rds")) %>%
  select(
    -c(sensor_type, int_sample, n_sample, rolling_sd_flag_temperature_degree_c)
  ) %>%
  mutate(
    depth = factor(sensor_depth_at_low_tide_m),
    month = month(timestamp_utc, label = TRUE)
  ) %>%
  rename(temperature_degree_c = value_temperature_degree_c) %>%
  filter(
    !(station %in% c("Piper Lake", "Hourglass Lake", "0193", "Sissiboo")),
    !(county == "Inverness" & depth %in% c(18, 23, 26, 28, 36, 40))
  )
```

Temperature thresholds were calculated from the historical Coastal Monitoring Program data. Preliminary quality control was applied to this data. Obvious outliers and data from freshwater stations were omitted.

Separate thresholds were calculated for each county due to expected and observed spatial differences in temperature (fig).


Separate thresholds were calculated for each county from the historical Coastal Monitoring Program temperature data. Preliminary quality control was applied to this data. Obvious outliers and data from freshwater stations were omitted.

Temperature thresholds were calculated by county because of expected and observed spatial differences, and because there .  is higher spatial resolution and more consisteent temporal data


Most counties have substantially different number of observations for different seasons. Because temperature has a clear seasonal cycle , this can weight the average towards months with more observations. To give each month equal weight, the user thresholds were based on the monthly climatology[^3].

[^3]: it was assumed that the different number of days per month was negligible




User thresholds were calculated separately for each county due to expected and observed spatial differences in temperature (@fig-temp-mean-sd).


The quality[^2] of these user thresholds may vary by county, depending on the number and distribution (in space and time) of observations. For example, there are relatively few observations for some counties compared to others (@fig-temp-n-obs). Cape Breton has the fewest observations at ~30,000 over 3 years and two stations, while Guysborough has the most at nearly 1 million over 7 years and 35 stations (@fig-temp-station-locations). Colchester and Queens counties only have one station each (@fig-temp-station-locations). For consistency, the counties with fewer observations were not pooled with counties with more observations. The user thresholds should be re-evaluated when more observations are collected.

[^2]: e.g., how representative the thresholds are of "normal" conditions through the water column and county


# Gross Range Test

## Sensor Thresholds

The sensor thresholds were determined based on the associated manual (Table 1).

:::panel-tabset
### Table 1

Table 1: Temperature sensor thresholds for the Gross Range Test.
```{r}
sensors %>% 
  filter(variable == "temperature_degree_c") %>%
  mutate(
    `Sensor Type (link to manual)` = 
      paste0('<a  target=_blank href=', url, '>', sensor_type,'</a>')
  ) %>% 
  select(`Sensor Type (link to manual)`, sensor_min, sensor_max ) %>%
  distinct() %>% 
  datatable(
    options <- list(
      dom = 'ft',
      searching = FALSE,
      columnDefs = list(list(className = 'dt-center', targets = "_all"))
    ), 
    rownames = FALSE, escape = FALSE
  )
```
:::

## User Thresholds

:::panel-tabset

### Figure 1
```{r}
#| warning: false
#| fig-height: 12
#| fig-cap: Distribution of temperature observations (binwidth = 1 degree C). Dotted orange lines indicate the user thresholds.
#| label: fig-temp-hist

user_temp <- dat_temp %>% 
  group_by(county) %>% 
  qc_calculate_user_thresholds(
    var = "temperature_degree_c",
    n_sd = 3, keep_stats = TRUE
  ) %>% 
  pivot_wider(names_from = threshold, values_from = threshold_value) %>% 
  select(county, mean = mean_var, stdev = sd_var, user_min, user_max) 

p <- plot_histogram(
  dat_temp, hist_col = temperature_degree_c, binwidth = 2, pal= hist_pal) +
  facet_wrap(~county, ncol = 2, scales = "free_y") +
  geom_vline(
    dat = user_temp, aes(xintercept = user_min), 
    linetype = 3, col = "#EDA247"
  ) +
  geom_vline(
    dat = user_temp, aes(xintercept = user_max),
    linetype = 3, col = "#EDA247"
  ) +
  scale_x_continuous("Temperature (degree C)") +
  theme_facet_plotly2

ggplotly(p, tooltip = "text")
```

### Table 2

Table 2: Gross Range Test statistics and user thresholds for temperature.
```{r}
user_temp %>% 
  datatable(options = dt_options, rownames = FALSE)
```
:::


Calculating thresholds at the county scale provides relatively coarse threshold values. Ideally, these would be resolved by depth and a smaller spatial scale (e.g., waterbody or station). However, calculating thresholds for each county and depth provides its own challenges. The data become very patchy when grouped by county, depth, and month (e.g., 169 month-county-depth combinations with 0 observations). Additionally, the same depth can represent a different part of the water column for different stations. At the Barren Island station in Guysborough county, the 15 m sensor is near the bottom. In contrast, 15 m is in the top 20 % of the water column at Tickle Island, also in Guysborough county. Finally, aggregating thresholds by county and depth would result in 141 user-defined temperature thresholds, which is more than the 2.5 person Data Governance team can reasonably manage.

Because depth was not accounted for, it is expected that observations from very shallow sensors (e.g., <= 2 m) will be assigned the [Suspect/Of Interest]{style="color: #EDA247;"} flag, despite appearing reasonable in the context of the deployment. In this case, the flag should be interpreted as ["Of Interest"]{style="color: #EDA247;"}, for highlighting a relatively warm observation.

The $user_{min}$ threshold is typically << 0 degrees Celsius (Table 2), and is therefore not expected to flag any observations. For most counties (all except Annapolis, Queens, Shelburne, and Digby), the $user_{min}$ is less than the $sensor_{min}$ for the aquameasure and vr2ar sensors. In this case, any observations less than the $sensor_{min}$ would [fail]{style="color: #DB4325;"} the Gross Range Test (i.e., the $user_{min}$ would be ignored). It may be useful for other users to apply their own $user_{min}$ threshold to highlight cold observations that are [Suspect/Of Interest]{style="color: #EDA247;"}. For example, those interested in salmonid aquaculture may wish to flag observations at or near the superchill threshold (-0.7 degree C).

### Depth & Stratification

Like the user thresholds, the seasonal thresholds were not resolved by depth. This means that there was high standard deviation for counties with seasonal stratification, particularly in the summer months when stratification is typically the strongest (@fig-temp-climatology; Table 3).

The standard deviations for July through October in Inverness are the four highest overall standard deviations (Table 3). This high variability was driven by three deployments in Whycocomagh Basin in the Bras D'Or Lakes:

-   Deep Basin (May to September 2018)
-   0814x East (September to December 2020)
-   0814x West (September to December 2020)

These stations had sensors deployed above and below the thermocline. Temperatures below the thermocline, near the bottom, were typically very cold (about zero degrees for the whole Deep Basin deployment). Temperatures above the thermocline, closer to the surface, were typically much warmer, up to 25 °C in the summer (**link to Inverness report here**). The high standard deviation results in a very wide range of °C in August.

The temperatures below the thermocline could be considered anomalous and removed prior to calculating the thresholds. These temperatures would then be flagged [Of Interest]{style="color: #EDA247;"}. However, the temperatures were included in the current thresholds analysis for several reasons:

1.  Together, these three deployments represent 68 % of the Inverness temperature observations (those from below the thermocline represents 30 % of the county observations).
2.  Consistency with the threshold calculation for other counties (e.g., depth was not accounted for).
3.  It is not [suspicious]{style="color: #EDA247;"} for these temperatures to be so cold in this region of Whycocomagh Basin.

There are stations withe notable depth stratification in other counties, including Guysborough, Halifax, and Lunenburg. This is reflected in the relatively high standard deviation in the summer months for these counties (@fig-temp-climatology; Table 3). Future iterations of this threshold analysis could consider resolving the seasonal thresholds by depth; however it is beyond the scope of the current exercise.


# Climatological Test

The season thresholds were calculated separately for each county due to expected and observed spatial differences in temperature (@fig-temp-climatology).

::: panel-tabset

### Figure 2
```{r}
#| fig-height: 12
#| fig-cap: Mean +/- 3 standard deviations of the monthly depth observations.
#| label: fig-temp-clim
#| message: false

temp_clim <- dat_temp %>% 
  group_by(county, month) %>% 
  summarise(
    mean = mean(temperature_degree_c), 
    stdev = sd(temperature_degree_c)
  ) %>% 
  ungroup() %>% 
  mutate(
    variable = "temperature_degree_c",
    season_min = round(mean - 3 * stdev, digits = 3),
    season_max = round(mean + 3 * stdev, digits = 3)
  )

p <- plot_mean_sd_season(temp_clim, n_sd = 3, facet_county = TRUE, ncol = 2) +
  scale_y_continuous("Temperature (degree C)") +
  theme_facet_plotly

ggplotly(p)

```

:::

### Figure 3

Seasonal distribution of depth observations (binwidth = 2 degree C). Dotted orange lines indicate the user thresholds.

::: panel-tabset

```{r}
#| warning: false
#| message: false
#| results: asis
#| fig-height: 1.5

plot_ly()

counties <- unique(user_temp$county)

for(i in seq_along(counties)) {
  
  county_i <- counties[i]
  temp_clim_i <- temp_clim %>% filter(county == county_i)
  
  cat(paste("### ", county_i, "\n \n"))
  
  p_i <- dat_temp %>%
    filter(county == county_i) %>% 
    plot_histogram(
      hist_col = temperature_degree_c, binwidth = 1, pal= hist_pal
    ) +
    scale_x_continuous("Temperature (degree C)") +
    facet_wrap(~month, ncol = 3) +
    geom_vline(
      dat = temp_clim_i, aes(xintercept = season_min), 
      linetype = 3, col = "#EDA247"
    ) +
    geom_vline(
      dat = temp_clim_i, aes(xintercept = season_max), 
      linetype = 3, col = "#EDA247"
    ) +
    theme(strip.background = element_rect(color = 1)) 
  
  print(
    htmltools::tagList(
      ggplotly(p_i, tooltip = "text", height = h_interactive())
    ))
  
  cat("\n\n")
}
```
:::

# Spike Test

Because of the difference in precision between the types of sensors that record depth, the Spike Test thresholds were calculated by county and sensor type (@fig-depth-spike-dist-a; @fig-depth-spike-dist-b).

For all groups, the distribution of the spike value is skewed right, and so several upper quartile values (90th, 95th, and 99.7th quartile) were evaluated to use as the $spike_{low}$. There were relatively few large single-value spikes in the depth data, and so the 99.7th quartile was selected to avoid false positives. $spike_{high}$ was defined as 3 * $spike_{low}$ to identify especially egregious spike values.

Distribution of the spike value of depth observations measured by aquaMeasure sensors (binwidth = 0.1 degree C). Dotted orange line indicates $spike_{low}$; dotted red line indicates $spike_{high}$. Note difference in y-axis scale.

### Figure 4

::: panel-tabset

```{r}
#| warning: false
#| message: false
#| results: asis
#| fig-height: 1

spike_thresh <- thresholds %>% 
  filter(variable == "temperature_degree_c", qc_test == "spike") %>% 
  pivot_wider(names_from = threshold, values_from = threshold_value) 

dat_sp <- dat_temp %>% 
  group_by(county, station, deployment_range, sensor_serial_number) %>%
  dplyr::arrange(timestamp_utc, .by_group = TRUE) %>%
  mutate(
    lag_value = lag(temperature_degree_c),
    lead_value = lead(temperature_degree_c),
    spike_ref = (lag_value + lead_value) / 2,
    spike_value = abs(temperature_degree_c - spike_ref)  
  ) %>% 
  ungroup() %>% 
  filter(!is.na(spike_value))

plot_ly()

for(i in seq_along(counties)) {
  
  county_i <- counties[i]
  spike_thresh_i <- spike_thresh %>% filter(county == county_i)
  
  cat(paste("### ", county_i, "\n \n"))
  
  p_i <- dat_sp %>% 
    filter(county == county_i) %>% 
    plot_histogram(hist_col = spike_value, binwidth = 0.1, pal = hist_pal) +
    geom_vline(
      dat = filter(spike_thresh, county == county_i), 
      aes(xintercept = spike_low), 
      col = "#EDA247", linetype = 3
    ) +
    geom_vline(
      dat = filter(spike_thresh, county == county_i), 
      aes(xintercept = spike_high), 
      col = "#DB4325", linetype = 3
    ) +
    scale_x_continuous("Temperature (degree C)\nSpike Value") +
    theme(strip.background = element_rect(color = 1)) 
  
  print(
    htmltools::tagList(
      ggplotly(p_i, tooltip = "text", height = h_interactive())
    ))
  
  cat("\n\n")
}

```
:::

::: panel-tabset

### Table 4

Table 4: Spike thresholds for temperature.
```{r}
spike_thresh %>% 
  select(county, spike_low, spike_high) %>% 
  datatable(options = dt_options, rownames = FALSE)
```
:::
  
  
# Rolling Standard Deviation Test

The distribution of rolling standard deviation is skewed right (@fig-do-roll-sd-dist), and so several upper quartile values were evaluated to use as the $rolling\_sd\_max$. 

The 90th, 95th, and 99.7th quartile values were each applied to the the raw data (no preliminary QC) and the results inspected. The 90th quartile was determined to be too stringent, as it flagged 31 % of the observations and generated false positives. The 99.7th quartile was determined to be too lenient, as only about 11 % of the observations were flagged, and visual inspection identified false negatives. The 95th quartile, which flagged 24 % of the observations, was considered the most useful threshold.

CMAR acknowledges that this is a very high percent of observations to flag as 
[Suspect/Of Interest]{style="color: #EDA247;"}. However, it was anticipated that a large proportion of the dissolved oxygen observations would be flagged by this test because there were substantial biofouling signals identified during the preliminary QC process. CMAR is currently assessing options to reduce biofouling on dissolved oxygen sensors.

There is no [Fail]{style="color: #DB4325;"} flag for the Rolling Standard Deviation Test because of the natural variability of the Water Quality variables. However, CMAR recommends that the dissolved oxygen observations flagged as [Suspect/Of Interest]{style="color: #EDA247;"} should be considered [Suspect]{style="color: #EDA247;"}, and filtered out of most analyses. 

::: panel-tabset

### Figure 5
```{r}
#| warning: false
#| message: false
#| results: asis
#| fig-height: 1

temp_roll_sd <- thresholds %>% 
  filter(
    variable == "temperature_degree_c", qc_test == "rolling_sd"
  ) %>% 
  select(county, threshold, threshold_value) %>% 
  pivot_wider(names_from = threshold, values_from = threshold_value) 


plot_ly()

for(i in seq_along(counties)) {
  
  county_i <- counties[i]
  roll_sd_i <- temp_roll_sd %>% filter(county == county_i)
  
  cat(paste("### ", county_i, "\n \n"))
  
  p_i <- dat_temp %>% 
    filter(!is.na(sd_roll), county == county_i) %>% 
    plot_histogram(
      hist_col = sd_roll, binwidth = 0.25, pal = hist_pal,
      user_thresh = roll_sd_i$rolling_sd_max
    ) +
    scale_x_continuous(
      "Temperature (degree C)\nRolling Standard Deviation")
  
   print(
    htmltools::tagList(
      ggplotly(p_i, tooltip = "text", height = h_interactive())
    ))
  
  cat("\n\n")
}
```

:::

::: panel-tabset

### Table 5

Table 5: Rolling standard deviation threshold for temperature.
```{r}
temp_roll_sd %>% 
  datatable(options = dt_options, rownames = FALSE)
```

:::